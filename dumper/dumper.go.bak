package dumper

import (
	"fmt"
	"io"
	"time"

	"github.com/RIscRIpt/indwriter"
	"github.com/RIscRIpt/pecoff"
)

type FileDumper struct {
	*pecoff.File
	iw *indwriter.Writer
}

func New(file *pecoff.File, w io.Writer) *FileDumper {
	return NewWithIndWriter(
		file,
		indwriter.New(w, []byte{'\n'}),
	)
}

func NewWithIndWriter(file *pecoff.File, iw *indwriter.Writer) *FileDumper {
	return &FileDumper{
		File: file,
		iw:   iw,
	}
}

func (fd *FileDumper) DumpAll() error {
	if err := fd.ReadAll(); err != nil {
		return err
	}
	fd.DumpHeaders()
	return nil
}

func (fd *FileDumper) DumpHeaders() {
	fmt.Fprintln(fd.iw, "DosHeader:")
	fd.iw.Indent()
	fd.DumpDosHeader()
	fmt.Fprintln(fd.iw)
	fd.iw.Unindent()

	fmt.Fprintln(fd.iw, "FileHeader:")
	fd.iw.Indent()
	fd.DumpFileHeader()
	fmt.Fprintln(fd.iw)
	fd.iw.Unindent()

	fmt.Fprintln(fd.iw, "OptionalHeader:")
	fd.iw.Indent()
	fd.DumpOptionalHeader()
	fmt.Fprintln(fd.iw)
	fd.iw.Unindent()

	// fmt.Fprintf(fd.iw, "SectionsHeaders:\t\n")
	// fd.iw.Indent()
	// fd.DumpSectionsHeaders()
	// fd.iw.Unindent()

	fd.iw.Flush()
}

func (fd *FileDumper) DumpDosHeader() {
	if fd.DosHeader == nil {
		return
	}
	fd.iw.SetColumns(fd.iw.GetIndent() + 3)
	fmt.Fprintf(fd.iw, "e_magic   \t%04X\tMagic number                    \n", fd.DosHeader.E_magic)
	fmt.Fprintf(fd.iw, "e_cblp    \t%04X\tBytes on last page of file      \n", fd.DosHeader.E_cblp)
	fmt.Fprintf(fd.iw, "e_cp      \t%04X\tPages in file                   \n", fd.DosHeader.E_cp)
	fmt.Fprintf(fd.iw, "e_crlc    \t%04X\tRelocations                     \n", fd.DosHeader.E_crlc)
	fmt.Fprintf(fd.iw, "e_cparhdr \t%04X\tSize of header in paragraphs    \n", fd.DosHeader.E_cparhdr)
	fmt.Fprintf(fd.iw, "e_minalloc\t%04X\tMinimum extra paragraphs needed \n", fd.DosHeader.E_minalloc)
	fmt.Fprintf(fd.iw, "e_maxalloc\t%04X\tMaximum extra paragraphs needed \n", fd.DosHeader.E_maxalloc)
	fmt.Fprintf(fd.iw, "e_ss      \t%04X\tInitial (relative) SS value     \n", fd.DosHeader.E_ss)
	fmt.Fprintf(fd.iw, "e_sp      \t%04X\tInitial SP value                \n", fd.DosHeader.E_sp)
	fmt.Fprintf(fd.iw, "e_csum    \t%04X\tChecksum                        \n", fd.DosHeader.E_csum)
	fmt.Fprintf(fd.iw, "e_ip      \t%04X\tInitial IP value                \n", fd.DosHeader.E_ip)
	fmt.Fprintf(fd.iw, "e_cs      \t%04X\tInitial (relative) CS value     \n", fd.DosHeader.E_cs)
	fmt.Fprintf(fd.iw, "e_lfarlc  \t%04X\tFile address of relocation table\n", fd.DosHeader.E_lfarlc)
	fmt.Fprintf(fd.iw, "e_ovno    \t%04X\tOverlay number                  \n", fd.DosHeader.E_ovno)
	fmt.Fprintf(fd.iw, "e_res     \t    \tReserved words                  \n")
	fd.iw.Indent()
	for _, v := range fd.DosHeader.E_res {
		fmt.Fprintf(fd.iw, "%04X\n", v)
	}
	fd.iw.Unindent()
	fmt.Fprintf(fd.iw, "e_oemid   \t%04X\tOEM identifier (for e_oeminfo)   \n", fd.DosHeader.E_oemid)
	fmt.Fprintf(fd.iw, "e_oeminfo \t%04X\tOEM information; e_oemid specific\n", fd.DosHeader.E_oeminfo)
	fmt.Fprintf(fd.iw, "e_res2    \t    \tReserved words                   \n")
	fd.iw.Indent()
	for _, v := range fd.DosHeader.E_res2 {
		fmt.Fprintf(fd.iw, "%04X\n", v)
	}
	fd.iw.Unindent()
	fmt.Fprintf(fd.iw, "e_lfanew  \t%08X\tFile address of new exe header   \n", fd.DosHeader.E_lfanew)
}

func (fd *FileDumper) DumpFileHeader() {
	if fd.FileHeader == nil {
		return
	}
	fd.iw.SetColumns(fd.iw.GetIndent() + 3)
	MachineString, ok := pecoff.MAP_IMAGE_FILE_MACHINE[fd.FileHeader.Machine]
	if !ok {
		MachineString = pecoff.MAP_IMAGE_FILE_MACHINE[pecoff.IMAGE_FILE_MACHINE_UNKNOWN]
	}
	TimeDateStamp := time.Unix(int64(fd.FileHeader.TimeDateStamp), 0)
	fmt.Fprintf(fd.iw, "Machine             \t%04X\t%s\n", fd.FileHeader.Machine, MachineString)
	fmt.Fprintf(fd.iw, "NumberOfSections    \t%04X\n", fd.FileHeader.NumberOfSections)
	fmt.Fprintf(fd.iw, "TimeDateStamp       \t%08X\t%s\n", fd.FileHeader.TimeDateStamp, TimeDateStamp)
	fmt.Fprintf(fd.iw, "PointerToSymbolTable\t%08X\n", fd.FileHeader.PointerToSymbolTable)
	fmt.Fprintf(fd.iw, "NumberOfSymbols     \t%08X\n", fd.FileHeader.NumberOfSymbols)
	fmt.Fprintf(fd.iw, "SizeOfOptionalHeader\t%04X\n", fd.FileHeader.SizeOfOptionalHeader)
	fmt.Fprintf(fd.iw, "Characteristics     \t%04X\n", fd.FileHeader.Characteristics)
	fd.iw.Indent()
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_RELOCS_STRIPPED != 0 {
		fmt.Fprintf(fd.iw, "RELOCS_STRIPPED         \tRelocation info stripped from file.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_EXECUTABLE_IMAGE != 0 {
		fmt.Fprintf(fd.iw, "EXECUTABLE_IMAGE        \tFile is executable  (i.e. no unresolved external references).\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_LINE_NUMS_STRIPPED != 0 {
		fmt.Fprintf(fd.iw, "LINE_NUMS_STRIPPED      \tLine nunbers stripped from file.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_LOCAL_SYMS_STRIPPED != 0 {
		fmt.Fprintf(fd.iw, "LOCAL_SYMS_STRIPPED     \tLocal symbols stripped from file.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_AGGRESIVE_WS_TRIM != 0 {
		fmt.Fprintf(fd.iw, "AGGRESIVE_WS_TRIM       \tAggressively trim working set\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_LARGE_ADDRESS_AWARE != 0 {
		fmt.Fprintf(fd.iw, "LARGE_ADDRESS_AWARE     \tApp can handle >2gb addresses\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_BYTES_REVERSED_LO != 0 {
		fmt.Fprintf(fd.iw, "BYTES_REVERSED_LO       \tBytes of machine word are reversed.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_32BIT_MACHINE != 0 {
		fmt.Fprintf(fd.iw, "32BIT_MACHINE           \t32 bit word machine.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_DEBUG_STRIPPED != 0 {
		fmt.Fprintf(fd.iw, "DEBUG_STRIPPED          \tDebugging info stripped from file in .DBG file\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP != 0 {
		fmt.Fprintf(fd.iw, "REMOVABLE_RUN_FROM_SWAP \tIf Image is on removable media, copy and run from the swap file.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_NET_RUN_FROM_SWAP != 0 {
		fmt.Fprintf(fd.iw, "NET_RUN_FROM_SWAP       \tIf Image is on Net, copy and run from the swap file.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_SYSTEM != 0 {
		fmt.Fprintf(fd.iw, "SYSTEM                  \tSystem File.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_DLL != 0 {
		fmt.Fprintf(fd.iw, "DLL                     \tFile is a DLL.\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_UP_SYSTEM_ONLY != 0 {
		fmt.Fprintf(fd.iw, "UP_SYSTEM_ONLY          \tFile should only be run on a UP machine\n")
	}
	if fd.FileHeader.Characteristics&pecoff.IMAGE_FILE_BYTES_REVERSED_HI != 0 {
		fmt.Fprintf(fd.iw, "BYTES_REVERSED_HI       \tBytes of machine word are reversed.\n")
	}
	fd.iw.Unindent()
}

func (fd *FileDumper) DumpOptionalHeader() {
	if fd.OptionalHeader == nil {
		return
	}
	fd.iw.SetColumns(fd.iw.GetIndent() + 3)
	// Standard fields
	var magicString string
	switch fd.OptionalHeader.Magic {
	case pecoff.IMAGE_NT_OPTIONAL_HDR32_MAGIC:
		magicString = "PE32"
	case pecoff.IMAGE_NT_OPTIONAL_HDR64_MAGIC:
		magicString = "PE32+"
	case pecoff.IMAGE_ROM_OPTIONAL_HDR_MAGIC:
		magicString = "ROM"
	default:
		magicString = "Unknown"
	}
	fmt.Fprintf(fd.iw, "Magic                   \t%04X\t(%s)\n", fd.OptionalHeader.Magic, magicString)
	fmt.Fprintf(fd.iw, "MajorLinkerVersion      \t%02X\n", fd.OptionalHeader.MajorLinkerVersion)
	fmt.Fprintf(fd.iw, "MinorLinkerVersion      \t%02X\n", fd.OptionalHeader.MinorLinkerVersion)
	fmt.Fprintf(fd.iw, "SizeOfCode              \t%08X\n", fd.OptionalHeader.SizeOfCode)
	fmt.Fprintf(fd.iw, "SizeOfInitializedData   \t%08X\n", fd.OptionalHeader.SizeOfInitializedData)
	fmt.Fprintf(fd.iw, "SizeOfUninitializedData \t%08X\n", fd.OptionalHeader.SizeOfUninitializedData)
	fmt.Fprintf(fd.iw, "AddressOfEntryPoint     \t%08X\n", fd.OptionalHeader.AddressOfEntryPoint)
	fmt.Fprintf(fd.iw, "BaseOfCode              \t%08X\n", fd.OptionalHeader.BaseOfCode)

	// PE32 field only
	if !fd.Is64Bit() {
		fmt.Fprintf(fd.iw, "BaseOfCode              \t%08X\n", fd.OptionalHeader.BaseOfData)
	}

	// Variable size fields (part 1)
	if !fd.Is64Bit() {
		fmt.Fprintf(fd.iw, "ImageBase               \t%08X\n", fd.OptionalHeader.ImageBase)
	} else {
		fmt.Fprintf(fd.iw, "ImageBase               \t%016X\n", fd.OptionalHeader.ImageBase)
	}

	// Extension fields (part 1)
	fmt.Fprintf(fd.iw, "SectionAlignment            \t%08X\n", fd.OptionalHeader.SectionAlignment)
	fmt.Fprintf(fd.iw, "FileAlignment               \t%08X\n", fd.OptionalHeader.FileAlignment)
	fmt.Fprintf(fd.iw, "MajorOperatingSystemVersion \t%04X\n", fd.OptionalHeader.MajorOperatingSystemVersion)
	fmt.Fprintf(fd.iw, "MinorOperatingSystemVersion \t%04X\n", fd.OptionalHeader.MinorOperatingSystemVersion)
	fmt.Fprintf(fd.iw, "MajorImageVersion           \t%04X\n", fd.OptionalHeader.MajorImageVersion)
	fmt.Fprintf(fd.iw, "MinorImageVersion           \t%04X\n", fd.OptionalHeader.MinorImageVersion)
	fmt.Fprintf(fd.iw, "MajorSubsystemVersion       \t%04X\n", fd.OptionalHeader.MajorSubsystemVersion)
	fmt.Fprintf(fd.iw, "MinorSubsystemVersion       \t%04X\n", fd.OptionalHeader.MinorSubsystemVersion)
	fmt.Fprintf(fd.iw, "Win32VersionValue           \t%08X\n", fd.OptionalHeader.Win32VersionValue)
	fmt.Fprintf(fd.iw, "SizeOfImage                 \t%08X\n", fd.OptionalHeader.SizeOfImage)
	fmt.Fprintf(fd.iw, "SizeOfHeaders               \t%08X\n", fd.OptionalHeader.SizeOfHeaders)
	fmt.Fprintf(fd.iw, "CheckSum                    \t%08X\n", fd.OptionalHeader.CheckSum)
	fmt.Fprintf(fd.iw, "Subsystem                   \t%04X\n", fd.OptionalHeader.Subsystem)
	fd.iw.Indent()
	switch fd.OptionalHeader.Subsystem {
	default:
	case pecoff.IMAGE_SUBSYSTEM_UNKNOWN:
		fmt.Fprintf(fd.iw, "UNKNOWN                  \tUnknown subsystem.\n")
	case pecoff.IMAGE_SUBSYSTEM_NATIVE:
		fmt.Fprintf(fd.iw, "NATIVE                   \tImage doesn't require a subsystem.\n")
	case pecoff.IMAGE_SUBSYSTEM_WINDOWS_GUI:
		fmt.Fprintf(fd.iw, "WINDOWS_GUI              \tImage runs in the Windows GUI subsystem.\n")
	case pecoff.IMAGE_SUBSYSTEM_WINDOWS_CUI:
		fmt.Fprintf(fd.iw, "WINDOWS_CUI              \tImage runs in the Windows character subsystem.\n")
	case pecoff.IMAGE_SUBSYSTEM_OS2_CUI:
		fmt.Fprintf(fd.iw, "OS2_CUI                  \tImage runs in the OS/2 character subsystem.\n")
	case pecoff.IMAGE_SUBSYSTEM_POSIX_CUI:
		fmt.Fprintf(fd.iw, "POSIX_CUI                \tImage runs in the Posix character subsystem.\n")
	case pecoff.IMAGE_SUBSYSTEM_NATIVE_WINDOWS:
		fmt.Fprintf(fd.iw, "NATIVE_WINDOWS           \tImage is a native Win9x driver.\n")
	case pecoff.IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:
		fmt.Fprintf(fd.iw, "WINDOWS_CE_GUI           \tImage runs in the Windows CE subsystem.\n")
	case pecoff.IMAGE_SUBSYSTEM_EFI_APPLICATION:
		fmt.Fprintf(fd.iw, "EFI_APPLICATION\n")
	case pecoff.IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
		fmt.Fprintf(fd.iw, "EFI_BOOT_SERVICE_DRIVER\n")
	case pecoff.IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
		fmt.Fprintf(fd.iw, "EFI_RUNTIME_DRIVER\n")
	case pecoff.IMAGE_SUBSYSTEM_EFI_ROM:
		fmt.Fprintf(fd.iw, "EFI_ROM\n")
	case pecoff.IMAGE_SUBSYSTEM_XBOX:
		fmt.Fprintf(fd.iw, "XBOX\n")
	case pecoff.IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION:
		fmt.Fprintf(fd.iw, "WINDOWS_BOOT_APPLICATION\n")
	}
	fd.iw.Unindent()
	fmt.Fprintf(fd.iw, "DllCharacteristics          \t%04X\n", fd.OptionalHeader.DllCharacteristics)
	fd.iw.Indent()
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA != 0 {
		fmt.Fprintf(fd.iw, "HIGH_ENTROPY_VA       \tImage can handle a high entropy 64-bit virtual address space.\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE != 0 {
		fmt.Fprintf(fd.iw, "DYNAMIC_BASE          \tDLL can move.\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY != 0 {
		fmt.Fprintf(fd.iw, "FORCE_INTEGRITY       \tCode Integrity Image\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_NX_COMPAT != 0 {
		fmt.Fprintf(fd.iw, "NX_COMPAT             \tImage is NX compatible\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_NO_ISOLATION != 0 {
		fmt.Fprintf(fd.iw, "NO_ISOLATION          \tImage understands isolation and doesn't want it\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_NO_SEH != 0 {
		fmt.Fprintf(fd.iw, "NO_SEH                \tImage does not use SEH.  No SE handler may reside in this image\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_NO_BIND != 0 {
		fmt.Fprintf(fd.iw, "NO_BIND               \tDo not bind this image.\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_APPCONTAINER != 0 {
		fmt.Fprintf(fd.iw, "APPCONTAINER          \tImage should execute in an AppContainer\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_WDM_DRIVER != 0 {
		fmt.Fprintf(fd.iw, "WDM_DRIVER            \tDriver uses WDM model\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_GUARD_CF != 0 {
		fmt.Fprintf(fd.iw, "GUARD_CF              \tImage supports Control Flow Guard.\n")
	}
	if fd.OptionalHeader.DllCharacteristics&pecoff.IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE != 0 {
		fmt.Fprintf(fd.iw, "TERMINAL_SERVER_AWARE\n")
	}
	fd.iw.Unindent()
}

// func (fd *FileDumper) DumpSectionsHeaders() {
// 	if fd.Sections == nil {
// 		return
// 	}
// 	for i := range fd.Sections {
// 		fd.Sections[i].Header
// 	}
// }

// func (fd *FileDumper) DumpDataDirectories() {
// 	fd.Imports(w)
// 	fd.BaseRelocations(w)
// }

// func (fd *FileDumper) DumpImports() {
// 	if fd.Imports == nil {
// 		return
// 	}
// 	for _, imp := range fd.Imports.Get() {
// 		imp.ImageImportDescriptor
// 		imp.Library()
// 		imp.Functions()
// 	}
// }

// func (fd *FileDumper) DumpBaseRelocations() {
// 	if fd.BaseRelocations == nil {
// 		return
// 	}
// 	for _, block := range fd.BaseRelocations.Get() {
// 		block.ImageBaseRelocation
// 		block.Entries()
// 	}
// }
